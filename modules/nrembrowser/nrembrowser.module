<?php
// $Id: nrembrowser.module,v 1.13.2.67 2010/09/22 20:38:48 jerseycheese Exp $

/**
 * @file
 * Node Reference/Embed Media Browser (nrembrowser).
 *
 * Provides a media thumbnail browser for editors to select nodes for fields
 * and inline inserts of embedded nodes. Works both with embedding nodes using
 * WYSIWYG and with nodereference fields.
 */

// A registry of variable_get defaults.
include_once('includes/nrembrowser.variables.inc');

/**
 * Implementation of hook_menu().
 */
function nrembrowser_menu() {
  $items = array(
    'admin/settings/nrembrowser' => array(
      'title' => 'Node Reference / Embed Media Browser',
      'description' => 'Administer the Node Reference / Embed Media Browser (nrembrowser) module.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('nrembrowser_settings'),
      'access arguments' => array('administer site configuration'),
      'file' => 'includes/nrembrowser.admin.inc',
    ),
    'nrembrowser/media/add' => array(
      'title' => 'Add media',
      'page callback' => 'nrembrowser_add_media_page',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/ahah/%/%/%' => array(
      'page callback' => 'nrembrowser_js',
      'page arguments' => array(2, 3, 4),
      'access callback' => 'nrembrowser_edit_access',
      'access arguments' => array(2, 3),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/browser/thumbnail/%node' => array(
      'title' => 'Media',
      'page callback' => 'nrembrowser_media_display_thumbnail',
      'page arguments' => array(3),
      'access callback' => 'node_access',
      'access arguments' => array('view', 3),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/media/tab' => array(
      'title' => 'Add media',
      'page callback' => 'nrembrowser_media_tab_page',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/node-add/js' => array(
      'title' => 'Media added',
      'page callback' => 'nrembrowser_node_add_js',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/style' => array(
      'title' => 'Style formatter selector',
      'page callback' => 'nrembrowser_style_formatter_selector_page',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'nrembrowser/style-preview' => array(
      'title' => 'Style preview',
      'page callback' => 'nrembrowser_style_preview',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
  );
  foreach (node_get_types('types', NULL, TRUE) as $type) {
    $type_url_str = str_replace('_', '-', $type->type);
    $items['nrembrowser/node/add/'. $type_url_str] = array(
      'title' => drupal_ucfirst($type->name),
      'title callback' => 'check_plain',
      'page callback' => 'nrembrowser_node_add',
      'page arguments' => array(3),
      'access callback' => 'node_access',
      'access arguments' => array('create', $type->type),
      'description' => $type->description,
      'type' => MENU_CALLBACK,
    );
  }
  return $items;
}

/**
 * Access callback for the JavaScript upload and deletion AHAH callbacks.
 *
 * The content_permissions module provides nice fine-grained permissions for
 * us to check, so we can make sure that the user may actually edit the file.
 */
function nrembrowser_edit_access($type_name, $field_name) {
  if (!content_access('edit', content_fields($field_name, $type_name))) {
    return FALSE;
  }
  // No content permissions to check, so let's fall back to a more general permission.
  return user_access('access content') || user_access('administer nodes');
}

/**
 * Implementation of hook_theme().
 */
function nrembrowser_theme($existing, $type, $theme, $path) {
  return array(
    'nrembrowser_browser' => array(
      'arguments' => array('element' => NULL),
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
    ),
    'nrembrowser_thumbnail' => array(
      'arguments' => array('nid' => NULL, 'alt' => '', 'title' => '', 'selected' => FALSE, 'id' => NULL, 'imagecache_preset' => NULL, 'attributes' => array(), 'link' => NULL),
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
    ),
    'nrembrowser_thumbnail_image' => array(
      'arguments' => array('nid' => NULL, 'alt' => '', 'title' => '', 'attributes' => array(), 'imagecache_preset' => NULL),
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
    ),
    'nrembrowser_view_node_js_wrapper' => array(
      'arguments' => array('thumbnail' => NULL),
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
    ),
    'nrembrowser_iframe' => array(
      'arguments' => array('url' => NULL),
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
      'template' => 'nrembrowser-iframe',
    ),
    'nrembrowser_node_add_page' => array(
      'arguments' => array('type' => NULL),
      'template' => 'nrembrowser-node-add-page',
      'path' => $path .'/themes',
      'file' => 'nrembrowser.theme.inc',
    ),
  );
}

/**
 * Implementation of hook_widget_info().
 */
function nrembrowser_widget_info() {
  return array(
    'nrembrowser_browser' => array(
      'label' => t('Media browser'),
      'field types' => array('nodereference'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_form_alter().
 */
function nrembrowser_form_alter(&$form, &$form_state, $form_id) {
  // We need to modify node edit/add forms launched by this module.
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id && (arg(0) == 'nrembrowser')) {
    // Add the relevant JS to process the form.
    drupal_add_js(drupal_get_path('module', 'nrembrowser') .'/themes/js/nrembrowser_node_form.js');

    // Attach ahah behavior to the save button.
    $form['buttons']['submit']['#ahah'] = array(
      'path' => 'nrembrowser/node-add/js',
      'wrapper' => 'nrembrowser-content',
      'method' => 'replace',
      'effect' => 'fade',
    );
  }

  // We need to remove WYSIWYG from all iframe'd node forms.
//   if (($form['#id'] == 'node-form') && (arg(0) == 'nrembrowser') && (arg(1) == 'node') && (arg(2) == 'add')) {
//     unset($form['field_summary'][0]['#columns'][1]);
//   }
}

/**
 * Page callback for nrembrowesr/style-preview.
 */
function nrembrowser_style_preview() {
  $nid = $_GET['nid'];
  if (module_exists('styles')) {
    $style_name = $_GET['styleName'] ? $_GET['styleName'] : '';
    $output = theme('styles', 'nodereference', $style_name, node_load($nid));
  }
  if (!$output) {
    $imagecache_preset = $_GET['imagecache'] ? $_GET['imagecache'] : '';
    $output = theme('nrembrowser_thumbnail', $nid, '', '', FALSE, NULL, $imagecache_preset);
  }
  $output = theme('status_messages') . $output;
  drupal_json(array('status' => TRUE, 'data' => $output));
}

/**
 * Page callback for nrembrowser/style.
 */
function nrembrowser_style_formatter_selector_page() {
  $nid_wrapper = $_GET['nid'];
  preg_match('@\[\[nid:(\d+)\]\]@i', $nid_wrapper, $matches);
  if ($nid = $matches[1]) {
    $node = node_load($nid);
    if (!node_access('view', $node)) {
      drupal_set_message(t('Fatal error: access denied to that content.'), 'error');
    }
    else {
      if (!$node->status) {
        drupal_set_message(t('Warning: The content referenced at !link is currently unpublished, which means that it may not be visible to all users.', array('!link' => l($node->title, 'node/'. $node->nid, array('attributes' => array('target' => '_blank'))))), 'warning');
      }
      $output = drupal_get_form('nrembrowser_style_formatter_selector_form', $nid);
    }
  }
  else {
    drupal_set_message(t('Fatal error: No match for %wrapper', array('%wrapper' => $nid_wrapper)), 'error');
  }
  $output = theme('status_messages') . $output;
  drupal_json(array('status' => TRUE, 'data' => $output));
}

/**
 * The Styles formatter select dialog when selecting from WYSIWYG.
 */
function nrembrowser_style_formatter_selector_form(&$form_state, $nid) {
  $form = array();
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $nid,
  );
  if (module_exists('styles')) {
    $styles = styles_default_styles('nodereference');
    // Add support for original size.
    $options = array('0' => t('<none>'));
    foreach ($styles['styles'] as $style) {
      $options[$style['name']] = $style['label'];
    }
    $default_value = nrembrowser_variable_get('default_wysiwyg_style');
    $preview = theme('styles', 'nodereference', $default_value, node_load($nid));
    $form['style'] = array(
      '#type' => 'select',
      '#title' => t('Style'),
      '#options' => $options,
      '#default_value' => $default_value,
    );
  }
  else if (module_exists('imagecache')) {
    $presets = imagecache_presets();
    $options = array();
    foreach ($presets as $preset) {
      $options[$preset['presetname']] = $preset['presetname'];
    }
    $default_value = nrembrowser_variable_get('default_wysiwyg_imagecache');
    $preview = theme('nrembrowser_thumbnail', $nid, '', '', FALSE, NULL, $default_value);
    $form['imagecache_preset'] = array(
      '#type' => 'select',
      '#title' => t('Imagecache Preset'),
      '#options' => $options,
      '#default_value' => $default_value,
    );
  }
  $form['preview'] = array(
    '#type' => 'item',
    '#value' => $preview,
    '#prefix' => '<div id="nrembrowser-style-formatter-selector-preview-wrapper">',
    '#suffix' => '</div>',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('OK'),
  );
  return $form;
}

/**
 * Page callback for nrembrowser/node-add/js.
 */
function nrembrowser_node_add_js() {
  if (empty($_POST['form_build_id'])) {
    // Invalid request.
    drupal_set_message(t('An unrecoverable error occurred. An uploaded file likely exceeded the maximum file size (@size) that this server supports.', array('@size' => format_size(file_upload_max_size()))), 'error');
    print drupal_to_js(array('data' => theme('status_messages')));
    exit;
  }

  module_load_include('inc', 'node', 'node.pages');

  // Build the new form.
  $form_state = array('submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);

  if (!$form) {
    // Invalid form_build_id.
    drupal_set_message(t('An unrecoverable error occurred. This form was missing from the server cache. Try reloading the page and submitting again.'), 'error');
    print drupal_to_js(array('data' => theme('status_messages')));
    exit;
  }

  // Build the form. This calls the file field's #value_callback function and
  // saves the uploaded file. Since this form is already marked as cached
  // (the #cache property is TRUE), the cache is updated automatically and we
  // don't need to call form_set_cache().
  $args = $form['#parameters'];
  $form_id = array_shift($args);
  // We will run some of the submit handlers so we need to disable redirecting.
  $form['#redirect'] = FALSE;
  // We need to process the form, prepare for that by setting a few internals
  // variables.
  $form['#post'] = $_POST;
  $form['#programmed'] = FALSE;
  $form_state['post'] = $_POST;

  // Build, validate and if possible, submit the form.
  drupal_process_form($form_id, $form, $form_state);
  // This call recreates the form relying solely on the form_state that the
  // drupal_process_form set up.
  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);

  // If the form failed validation, then display errors & form.
  if (form_get_errors() || !$form_state['nid']) {
    $output = theme('status_messages') . drupal_render($form);
    $javascript = drupal_add_js ( NULL, NULL, 'header' );
    print drupal_to_js (array('status' => TRUE, 'data' => $output, 'settings' => call_user_func_array('array_merge_recursive', $javascript['setting'])));
    exit;
  }

  // We have a new node, so we need to send that through for processing.
  $nid = $form_state['nid'];
  $title = $form_state['node']['title'];

  // Render the new output. Fields use [nid:123], so we put that in the title.
  $title = check_plain($title .' [nid:'. $nid .']');
  // WYSIWYG uses [[nid:456]], so we add that to the alt.
  $alt = check_plain("[[nid:{$nid}]]");
  $imagecache_preset = nrembrowser_variable_get('imagecache_preset');
  $output = theme('status_messages') . theme('nrembrowser_view_node_js_wrapper', theme('nrembrowser_thumbnail', $nid, $alt, $title, TRUE, NULL, $imagecache_preset));

  // Add any settings.
  $javascript = drupal_add_js ( NULL, NULL, 'header' );

  // Don't call drupal_json(). If we have any file fields or attached files on
  // this node, ahah.js uses an iframe and the header output by drupal_json(),
  // which causes problems in some browsers.
  // @see http://drupal.org/node/399676
  // We also need to shut down devel: @see http://drupal.org/node/278562
  $GLOBALS['devel_shutdown'] = FALSE;
  print drupal_to_js (array('status' => TRUE, 'data' => $output, 'settings' => call_user_func_array('array_merge_recursive', $javascript['setting'])));
  exit;
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 */
function nrembrowser_elements() {
  return array(
    'nrembrowser_browser' => array(
      '#input' => TRUE,
      '#columns' => array('nid'), '#delta' => 0,
      '#process' => array('nrembrowser_browser_process'),
      '#element_validate' => array('nrembrowser_browser_element_validate'),
    ),
  );
}

/**
 * Display a warning when editing if a field references an unpublished node.
 */
function nrembrowser_browser_element_validate($element, &$form_state) {
  $nid = $form_state['values'][$element['#field_name']][$element['#delta']]['nid'];
  if ($node = node_load($nid)) {
    if (!node_access('view', $node)) {
      $form_state['values'][$element['#field_name']][$element['#delta']]['nid'] = 0;
      form_set_error($form_state['values'][$element['#field_name']][$element['#delta']]['_error_element'], t('Fatal error: Access denied to that content.'));
    }
    else {
      if (!$node->status) {
        drupal_set_message(t('Warning: The content referenced at !link is currently unpublished, which means that it may not be visible to all users.', array('!link' => l($node->title, 'node/'. $node->nid, array('attributes' => array('target' => '_blank'))))), 'warning');
      }
    }
  }
}

/**
 * Implementation of hook_widget_settings().
 */
function nrembrowser_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = array();
      $match = isset($widget['autocomplete_match']) ? $widget['autocomplete_match'] : 'contains';
      $size = (isset($widget['size']) && is_numeric($widget['size'])) ? $widget['size'] : 60;
      $form['autocomplete_match'] = array('#type' => 'hidden', '#value' => $match);
      $form['size'] = array('#type' => 'hidden', '#value' => $size);
      if ($widget['type'] == 'nrembrowser_browser') {
      }
      return $form;

    case 'save':
      return array('autocomplete_match', 'size');
  }
}

/**
 * Implementation of hook_widget().
 *
 * Attach a single form element to the form. It will be built out and
 * validated in the callback(s) listed in hook_elements. We build it
 * out in the callbacks rather than here in hook_widget so it can be
 * plugged into any module that can provide it with valid
 * $field information.
 *
 * Content module will set the weight, field name and delta values
 * for each form element. This is a change from earlier CCK versions
 * where the widget managed its own multiple values.
 *
 * If there are multiple values for this field, the content module will
 * call this function as many times as needed.
 *
 * @param $form
 *   the entire form array, $form['#node'] holds node information
 * @param $form_state
 *   the form_state, $form_state['values'][$field['field_name']]
 *   holds the field's form values.
 * @param $field
 *   the field array
 * @param $items
 *   array of default values for this field
 * @param $delta
 *   the order of this item in the array of subelements (0, 1, 2, etc)
 *
 * @return
 *   the form item for a single element for this field
 */
function nrembrowser_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'nrembrowser_browser':
      $element = array(
        '#type' => 'nrembrowser_browser',
        '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
        '#value_callback' => 'nodereference_autocomplete_value',
      );
      break;
  }
  return $element;
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 * The $fields array is in $form['#field_info'][$element['#field_name']].
 */
function nrembrowser_browser_process($element, $edit, $form_state, $form) {
  static $js_added = FALSE;
  static $ids_added;

  if (!isset($ids_added)) {
    $ids_added = array();
  }

  // The nodereference autocomplete widget doesn't need to create its own
  // element, it can wrap around the text_textfield element and add an autocomplete
  // path and some extra processing to it.
  // Add a validation step where the value can be unwrapped.
  $field_key = $element['#columns'][0];

  $element['nrembrowser_remove'] = array(
    // With default CCK edit forms, $element['#parents'] is array($element['#field_name'], $element['#delta']).
    // However, if some module (for example, flexifield) places our widget deeper in the tree, we want to
    // use that information in constructing the button name.
    '#name' => implode('_', $element['#parents']) .'_nrembrowser_remove',
    '#type' => 'submit',
    '#value' => t('Remove'),
    '#submit' => array('node_form_submit_build_node'),
    '#ahah' => array( // with JavaScript
      'path' => 'nrembrowser/ahah/'.   $element['#type_name'] .'/'. $element['#field_name'] .'/'. $element['#delta'],
      'wrapper' => $element['#id'] .'-ahah-wrapper',
      'method' => 'replace',
      'effect' => 'fade',
    ),
    '#field_name' => $element['#field_name'],
    '#delta' => $element['#delta'],
    '#weight' => 101,
    '#post' => $element['#post'],
  );

  // Because the output of this field changes depending on the button clicked,
  // we need to ask FAPI immediately if the remove button was clicked.
  // It's not good that we call this private function, but
  // $form_state['clicked_button'] is only available after this #process
  // callback is finished.
  if (_form_button_was_clicked($element['nrembrowser_remove'])) {
    $element['#value']['nid'] = NULL;
    $element['#default_value']['nid'] = NULL;
    $element['#post'][$element['#field_name']][$element['#delta']]['nid'] = NULL;
  }

  // Set access on the buttons.
  $element['nrembrowser_remove']['#access'] = !empty($element['#value']['nid']);

  $element[$field_key] = array(
    '#type' => 'text_textfield',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    '#autocomplete_path' => 'nodereference/autocomplete/'. $element['#field_name'],
    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
  );

  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'nodereference_autocomplete_validate');

  // Used so that hook_field('validate') knows where to flag an error.
  $element['_error_element'] = array(
    '#type' => 'value',
    // Wrapping the element around a text_textfield element creates a
    // nested element, so the final id will look like 'field-name-0-nid-nid'.
    '#value' => implode('][', array_merge($element['#parents'], array($field_key, $field_key))),
  );

  // Add the validation function to the form element.
  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'nrembrowser_browser_validate');

  $settings = NULL;
  if (!isset($ids_added[$element['#id']])) {
    $ids_added[$element['#id']] = TRUE;
    $settings = array(
      'nrembrowser' => array(
        $element['#id'] => array(
          'id' => $element['#id'],
          'fieldName' => $element['#field_name'],
          'launchURL' => url('nrembrowser/media/add/'. $element['#field_name']),
          'launchLink' => l(t('Add content'), 'nrembrowser/media/add/'. $element['#field_name'], array('attributes' => array('class' => 'nrembrowser-launch-link'))),
        ),
      ),
    );
  }

  nrembrowser_add_js($settings);

  $element['#attributes']['id'] = $element['#id'] .'-ahah-wrapper';
  $element['#prefix'] = '<div '. drupal_attributes($element['#attributes']) .'>';
  $element['#suffix'] = '</div>';

  return $element;
}

function nrembrowser_node_add($type) {
  print theme('nrembrowser_node_add_page', $type);
}


function nrembrowser_add_js($settings = NULL) {
  static $js_added;

  if (isset($settings)) {
    drupal_add_js($settings, 'setting');
  }

  if (!$js_added) {
    $js_added = TRUE;
    $settings = array(
      'mediaBrowserUrl' => url('nrembrowser/media/add'),
    );
    if (module_exists('styles') && nrembrowser_variable_get('wysiwygStyleFormatterSelect')) {
      $settings['getStyleURL'] = url('nrembrowser/style');
      $settings['getStylePreviewURL'] = url('nrembrowser/style-preview');
    }
    drupal_add_js(array('nrembrowser' => $settings), 'setting');
    jquery_ui_add(array('ui.draggable', 'ui.resizable', 'ui.dialog', 'ui.tabs'));
    drupal_add_css(drupal_get_path('module', 'jquery_ui') .'/jquery.ui/themes/default/ui.all.css');
    drupal_add_css(drupal_get_path('module', 'nrembrowser') .'/themes/css/nrembrowser.widget.css');
    drupal_add_js(drupal_get_path('module', 'nrembrowser') .'/themes/js/nrembrowser.widget.js');
  }
}

/**
 * Validate a select/buttons element.
 *
 * Remove the wrapper layer and set the right element's value.
 * We don't know exactly where this element is, so we drill down
 * through the element until we get to our key.
 *
 * We use $form_state['values'] instead of $element['#value']
 * to be sure we have the most accurate value when other modules
 * like optionwidgets are using #element_validate to alter the value.
 */
function nrembrowser_browser_validate($element, &$form_state) {
  $field_key  = $element['#columns'][0];

  $value = $form_state['values'];
  $new_parents = array();
  foreach ($element['#parents'] as $parent) {
    $value = $value[$parent];
    // Use === to be sure we get right results if parent is a zero (delta) value.
    if ($parent === $field_key) {
      $element['#parents'] = $new_parents;
      form_set_value($element, $value, $form_state);
      break;
    }
    $new_parents[] = $parent;
  }
}

/**
 * Implementation of hook_imagecache_default_presets()
 */
function nrembrowser_imagecache_default_presets() {
  $presets = array();
  $presets['nrembrowser_thumbnail'] = array(
    'presetname' => 'nrembrowser_thumbnail',
    'actions' => array(
      0 => array(
        'weight' => '0',
        'module' => 'imagecache',
        'action' => 'imagecache_scale_and_crop',
        'data' => array(
          'width' => nrembrowser_variable_get('thumbnail_width'),
          'height' => nrembrowser_variable_get('thumbnail_height'),
        )
      )
    )
  );
  return $presets;
}

/**
 * Determine the image associated with a node.
 *
 * @param integer $nid
 *  The node ID.
 * @param string $field_name
 *  (Optional) How to derive the node; value determines where to grab the image:
 *    'teaser' => (Default) Grab the first image present in the node teaser.
 *    'body' => Grab the first image present in the node body.
 *    'field_FIELD_NAME' => Take the image from the first delta of this field.
 *      This will accept fields of type FileField, ImageField, Embedded Media
 *      Field, Link, or Text.
 * @return string
 *  The URL to the image.
 */
function nrembrowser_node_image($nid, $field_name = NULL) {
  static $urls;

  if (!isset($urls)) {
    $urls = array();
  }

  if (!isset($urls[$nid])) {
    $urls[$nid] = array();
  }

  $node = node_load($nid);
  if (!node_access('view', $node)) {
    return FALSE;
  }

  if (!isset($field_name)) {
    $field_name = nrembrowser_variable_get('browser_image_'. $node->type);
  }

  if (!isset($urls[$nid][$field_name])) {
    // Stop an endless loop in its tracks if we're self-referential.
    $urls[$nid][$field_name] = '';
    switch ($field_name) {
      case 'teaser':
      case 'full':
        global $base_url;
        $text = node_view($node, ($field_name == 'teaser'), FALSE, FALSE);
        $url = nrembrowser_parse_image_url($text, TRUE);
        break;
      default:
        if ($node->{$field_name}[0]) {
          $field = content_fields($field_name);
          switch ($field['type']) {
            case 'filefield':
              $url = $node->{$field_name}[0]['filepath'];
              break;
            case 'text':
              $url = nrembrowser_parse_image_url($node->{$field_name}[0]['value'], $field['text_processing']);
              break;
            case 'emvideo':
              $url = theme('emvideo_video_thumbnail', $field, $node->{$field_name}[0], 'thumbnail', $node, FALSE, array('return_url' => TRUE, 'raw' => TRUE));
              break;
            case 'emimage':
            case 'emaudio':
              break;
            case 'link':
              $url = nrembrowser_parse_image_url($node->{$field_name}[0]['url']);
              break;
          }
        }
    }
    $urls[$nid][$field_name] = $url ? $url : nrembrowser_variable_get('wysiwyg_default_icon');
  }

  return $urls[$nid][$field_name];
}

/**
 * Parse an image URL directly from a string.
 */
function nrembrowser_parse_image_url($text, $from_html = FALSE) {
  global $base_root, $base_path;
  if ($from_html) {
    $regex = "@<img.+?src\s*?=\s*?[\"']?({$base_root}{$base_path})?([^\"'\?]+?\.(png|jpg|gif|jpeg))[\"']?.*?>@i";
  }
  else {
    $regex = "@^({$base_root}{$base_path})?([^\?]+?\.(png|jpg|gif|jpeg))$@i";
  }
  if (preg_match($regex, $text, $matches)) {
    return $matches[2];
  }
}

/**
 * Fetch an array of all candidate referenced nodes.
 *
 * This info is used in various places (allowed values, autocomplete results,
 * input validation...). Some of them only need the nids, others nid + titles,
 * others yet nid + titles + rendered row (for display in widgets).
 * The array we return contains all the potentially needed information, and lets
 * consumers use the parts they actually need.
 *
 * @param $field
 *   The field description.
 * @param $string
 *   Optional string to filter titles on (used by autocomplete).
 * @param $match
 *   Operator to match filtered name against, can be any of:
 *   'contains', 'equals', 'starts_with'
 * @param $ids
 *   Optional node ids to lookup (the $string and $match arguments will be
 *   ignored).
 * @param $limit
 *   If non-zero, limit the size of the result set.
 *
 * @return
 *   An array of valid nodes in the form:
 *   array(
 *     nid => array(
 *       'title' => The node title,
 *       'rendered' => The text to display in widgets (can be HTML)
 *     ),
 *     ...
 *   )
 */
function _nrembrowser_potential_references($field, $string = '', $match = 'contains', $ids = array(), &$options = NULL) {
  static $results = array();

  // Create unique id for static cache.
  $cid = $field['field_name'] .':'. $match .':'. ($string !== '' ? $string : implode('-', $ids)) .':'. $options['items_per_page'];
  if (!isset($results[$cid])) {
    $references = FALSE;
    if (module_exists('views') && !empty($field['advanced_view']) && $field['advanced_view'] != '--') {
      $options['view_name'] = $field['advanced_view'];
      $options['view_display_id'] = 'default';
      $options['view_arguments'] = $field['advanced_view_args'];
      $references = nrembrowser_build_view($options);
    }
    // If the view doesn't exist, we got FALSE, and fallback to the regular 'standard mode'.

    if ($references === FALSE) {
      $references = _nrembrowser_potential_references_standard($field, $string, $match, $ids, $options);
    }

    // Store the results.
    $results[$cid] = !empty($references) ? $references : array();
  }

  return $results[$cid];
}

/**
 * Helper function for _nodereference_potential_references():
 * referenceable nodes defined by content types.
 */
function _nrembrowser_potential_references_standard($field, $string = '', $match = 'contains', $ids = array(), $options) {
  $related_types = array();
  $where = array();
  $args = array();

  if (is_array($field['referenceable_types'])) {
    foreach (array_filter($field['referenceable_types']) as $related_type) {
      $related_types[] = "n.type = '%s'";
      $args[] = $related_type;
    }
  }

  $where[] = implode(' OR ', $related_types);

  if (!count($related_types)) {
    return array();
  }

  if ($string !== '') {
    $like = $GLOBALS["db_type"] == 'pgsql' ? "ILIKE" : "LIKE";
    $match_clauses = array(
      'contains' => "$like '%%%s%%'",
      'equals' => "= '%s'",
      'starts_with' => "$like '%s%%'",
    );
    $where[] = 'n.title '. (isset($match_clauses[$match]) ? $match_clauses[$match] : $match_clauses['contains']);
    $args[] = $string;
  }
  elseif ($ids) {
    $where[] = 'n.nid IN (' . db_placeholders($ids) . ')';
    $args = array_merge($args, $ids);
  }

  $where_clause = $where ? 'WHERE ('. implode(') AND (', $where) .')' : '';
  $sql = db_rewrite_sql("SELECT n.nid, n.title AS node_title, n.type AS node_type FROM {node} n $where_clause ORDER BY n.created DESC");
  $result = $options['items_per_page'] ? pager_query($sql, $options['items_per_page'], $options['pager_element'], NULL, $args) : db_query($sql, $args);
  $references = array();
  while ($node = db_fetch_object($result)) {
    $references[$node->nid] = array(
      'title' => $node->node_title,
      'rendered' => check_plain($node->node_title),
    );
  }

  return $references;
}

/**
 * Build a custom view of thumbnails for the browser.
 */
function nrembrowser_build_view(&$options) {
  $references = array();

  // Get the view.
  $view = $options['view'];

  // Only display the view if we have access.
  if ($view && $view->access($options['view_display_id'])) {
    // Grab each result and build up the reference array.
    if ($view->display[$options['view_display_id']]->display_options['header']) {
      $options['header'] = check_markup($view->display[$options['view_display_id']]->display_options['header'], $view->display[$options['view_display_id']]->display_options['header_format']);
      $options['header_empty'] = $view->display[$options['view_display_id']]->display_options['header_empty'];
    }
    if ($view->display[$options['view_display_id']]->display_options['footer']) {
      $options['footer'] = check_markup($view->display[$options['view_display_id']]->display_options['footer'], $view->display[$options['view_display_id']]->display_options['footer_format']);
      $options['footer_empty'] = $view->display[$options['view_display_id']]->display_options['footer_empty'];
    }
    if ($view->display[$options['view_display_id']]->display_options['empty']) {
      $options['empty_message'] = check_markup($view->display[$options['view_display_id']]->display_options['empty'], $view->display[$options['view_display_id']]->display_options['empty_format']);
    }

    $options['use_pager'] = $view->pager['use_pager'];
    $options['items_per_page'] = $view->pager['items_per_page'];
    $options['pager_element'] = $view->pager['element'];

    foreach ($view->result as $node) {
      // Get the title if we have it.
      $node->title = $node->node_title;

      // Convert to an array for later use.
      $references[$node->nid] = (array)$node;
    }
  }

  // We simply returned the found items for later display.
  return $references;
}

/**
 * Ensure the exposed filter form of views redirects to current page.
 */
function nrembrowser_form_views_exposed_form_alter(&$form, &$form_state) {
  if (arg(0) == 'nrembrowser' && arg(1) == 'media' && arg(2) == 'tab') {
    // We would simply attach ahah behavior, except for
    // http://drupal.org/node/630424.
    $form['#action'] = url($_GET['q'], array('query' => 'js=1&'. drupal_query_string_encode($_GET, array('q'))));
  }
}

/**
 * Return an array of all node types allowed to be filtered in WYSIWYG.
 */
function nrembrowser_wysiwyg_allowed_types() {
  static $allowed_types;

  if (!isset($allowed_types)) {
    $allowed_types = array();

    // Check each node type to see if it's allowed.
    foreach (node_get_types() as $type => $object) {
      if (nrembrowser_variable_get('wysiwyg_type_allowed_'. $type)) {
        // This type is allowed.
        $allowed_types[$type] = $type;
      }
    }
  }
  return $allowed_types;
}

/**
 * Return an array of all node types allowed by the field type.
 *
 * Note that this doesn't work for fields using an advanced view as the filter.
 * @TODO: Figure out a good fix for the above problem.
 */
function nrembrowser_field_allowed_types($field_name) {
  static $allowed_types;

  if (!isset($allowed_types)) {
    $allowed_types = array();
  }

  $field_name = $field_name ? $field_name : 'wysiwyg';

  if (!isset($allowed_types[$field_name])) {
    $allowed_types[$field_name] = array();

    if ($field_name != 'wysiwyg') {
      $field = content_fields($field_name);
      // We'll filter by the allowed types for this field.
      foreach ($field['referenceable_types'] as $type => $allowed) {
        if ($allowed) {
          $allowed_types[$field['field_name']][$type] = $type;
        }
      }
    }
    else {
      $allowed_types['wysiwyg'] = nrembrowser_wysiwyg_allowed_types();
    }
  }

  return $allowed_types[$field_name];
}

/**
 * Build the form for our library browser.
 *
 * @param array &$form_state
 *  The current form_state.
 * @param array $field
 *  (Optional) If set, then we need to build the form for a specific noderef.
 *  Otherwise, this is in a WYSIWYG editor.
 * @param integer $nid
 *  (Optional) The currently selected node.
 * @param array $options
 *  (Optional) An array of options passed from hook_nrembrowser_media.
 *  If the 'types' key is set to an array of node types, then the displayed
 *  media will be filtered by those types.
 */
function nrembrowser_add_media_page_form(&$form_state, $field = NULL, $nid = NULL, $options = array()) {
  $form = array();

  // Set default options.
  $options['header'] = isset($options['header']) ? $options['header'] : nrembrowser_variable_get('header');
  $options['header_empty'] = isset($options['header_empty']) ? $options['header_empty'] : nrembrowser_variable_get('header_empty');
  $options['footer'] = isset($options['footer']) ? $options['footer'] : nrembrowser_variable_get('footer');
  $options['footer_empty'] = isset($options['footer_empty']) ? $options['footer_empty'] : nrembrowser_variable_get('footer_empty');
  $options['empty_message'] = isset($options['empty_message']) ? $options['empty_message'] : nrembrowser_variable_get('empty_message');
  $options['use_pager'] = isset($options['use_pager']) ? $options['use_pager'] : nrembrowser_variable_get('use_pager');
  $options['items_per_page'] = isset($options['items_per_page']) ? $options['items_per_page'] : nrembrowser_variable_get('items_per_page');
  $options['pager_element'] = isset($options['pager_element']) ? $options['pager_element'] : nrembrowser_variable_get('pager_element');

  $options['exposed_filters'] = NULL;

  // If this is the default 'All' tab of a field, then return all allowed types.
  if (!empty($field) && !isset($options['types']) && !isset($options['view_name'])) {
    // This will return all available nodes.
    // @TODO: Rewrite for a pager limit...
    $references = _nrembrowser_potential_references($field, '', 'contains', array(), $options);
  }
  else {
    // What nodes should we display?
    $references = array();

    if (empty($field)) {
      // This is a WYSIWYG, not a field. We use the global settings.
      $allowed_types = nrembrowser_wysiwyg_allowed_types();
    }
    else {
      // This is a field. We'll filter by the allowed types.
      $allowed_types = nrembrowser_field_allowed_types($field['field_name']);
    }

    // If we're on a tab to filter by types, then remove any not present.
    if (isset($options['types'])) {
      $allowed_types = array_intersect($allowed_types, $options['types']);
      foreach ($allowed_types as $type) {
        if (node_access('create', $type)) {
          $type_url_str = str_replace('_', '-', $type);
          $url = 'nrembrowser/node/add/'. $type_url_str;
          $form['add_'. $type] = array(
            '#type' => 'fieldset',
            '#title' => t('Add @type', array('@type' => node_get_types('name', $type))),
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
          );
          $form['add_'. $type]['add'] = array(
            '#type' => 'item',
            '#value' => theme('nrembrowser_iframe', $url),
          );
        }
      }
    }

    // Filter nodes by views.
    if (isset($options['view_name'])) {
      $references = nrembrowser_build_view($options);
    }
    else {
      // Get the db placeholders for our array of allowed types.
      $placeholders = db_placeholders($allowed_types, 'varchar');

      // Write the SQL.
      $sql = db_rewrite_sql("SELECT nid, title FROM {node} WHERE type in ($placeholders) ORDER BY created DESC");
      if ($options['use_pager']) {
        $results = pager_query($sql, $options['items_per_page'], $options['pager_element'], NULL, $allowed_types);
      }
      else {
        $results = db_query($sql, $allowed_types);
      }
      while ($result = db_fetch_array($results)) {
        $references[$result['nid']] = $result;
      }
    }
  }

  // Determine the current selection.
  $nid = nrembrowser_add_media_page_current_nid($field, $nid);

  if ($nid && $references[$nid]) {
    $references[$nid]['current'] = $nid;
    $default_value = $nid;
  }

  $nodes = array();
  foreach ($references as $nid => $row) {
    $selected = !empty($row['current']);
    $title = $row['title'] .' [nid:'. $nid .']';
    $alt = "[[nid:$nid]]";
    $nodes[$nid] = theme('nrembrowser_thumbnail', $nid, $alt, $title, $selected, NULL, nrembrowser_variable_get('imagecache_preset'));
  }

  if (empty($references)) {
    $options['header'] = $options['header_empty'] ? $options['header'] : '';
    $options['footer'] = $options['footer_empty'] ? $options['footer'] : '';
  }

  if ($options['header']) {
    $form['header'] = array(
      '#type' => 'item',
      '#value' => $options['header'],
    );
  }

  if ($options['exposed_filters']) {
//     $form['exposed_filters'] = array(
//       '#type' => 'item',
//       '#value' => $options['exposed_filters'],
//     );
  }

  if (empty($references)) {
    if ($options['empty_message']) {
      $form['empty_message'] = array(
        '#type' => 'item',
        '#value' => $options['empty_message'],
      );
    }
  }
  else {
    $form['media'] = array(
      '#type' => 'radios',
      '#title' => t('Choose media'),
      '#options' => $nodes,
      '#default_value' => $default_value,
    );
  }

  if ($options['footer']) {
    $form['footer'] = array(
      '#type' => 'item',
      '#value' => $options['footer'],
    );
  }

  if ($options['use_pager']) {
    $form['pager'] = array(
      '#type' => 'item',
      '#value' => theme('pager', array(), $options['items_per_page'], $options['pager_element']),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('OK'),
  );
  return $form;
}

/**
 * Menu callback; Shared AHAH callback for uploads and deletions.
 *
 * This rebuilds the form element for a particular field item. As long as the
 * form processing is properly encapsulated in the widget element the form
 * should rebuild correctly using FAPI without the need for additional callbacks
 * or processing.
 */
function nrembrowser_js($type_name, $field_name, $delta) {
  $field = content_fields($field_name, $type_name);

  if (empty($field) || empty($_POST['form_build_id'])) {
    // Invalid request.
    drupal_set_message(t('An unrecoverable error occurred. The uploaded file likely exceeded the maximum file size (@size) that this server supports.', array('@size' => format_size(file_upload_max_size()))), 'error');
    print drupal_to_js(array('data' => theme('status_messages')));
    exit;
  }

  // Build the new form.
  $form_state = array('submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);

  if (!$form) {
    // Invalid form_build_id.
    drupal_set_message(t('An unrecoverable error occurred. This form was missing from the server cache. Try reloading the page and submitting again.'), 'error');
    print drupal_to_js(array('data' => theme('status_messages')));
    exit;
  }

  // Build the form.
  $args = $form['#parameters'];
  $form_id = array_shift($args);
  $form['#post'] = $_POST;
  $form = form_builder($form_id, $form, $form_state);

  // Update the cached form with the new element at the right place in the form.
  if (module_exists('fieldgroup') && ($group_name = _fieldgroup_field_get_group($type_name, $field_name))) {
    if (isset($form['#multigroups']) && isset($form['#multigroups'][$group_name][$field_name])) {
      $form_element = $form[$group_name][$delta][$field_name];
    }
    else {
      $form_element = $form[$group_name][$field_name][$delta];
    }
  }
  else {
    $form_element = $form[$field_name][$delta];
  }

  if (isset($form_element['_weight'])) {
    unset($form_element['_weight']);
  }

  $output = drupal_render($form_element);

  $output = theme('status_messages') . $output;

  drupal_json(array('status' => TRUE, 'data' => $output));
}

/**
 * Page callback for nrembrowser/media/tab.
 *
 * This will display the form for a specific tab of the dialog browser.
 */
function nrembrowser_media_tab_page($tab_name) {
  $js = $_GET['js'];
  unset($_GET['js']);
  $field_name = $_GET['field_name'];
  $nid = $_GET['current'];
  $field = $field_name ? content_fields($field_name) : NULL;

  $tabs = module_invoke_all('nrembrowser_media', $field);

  // Invoke hook_nrembrowser_media_alter().
  drupal_alter('nrembrowser_media', $tabs, $field);

  if (isset($tabs[$tab_name])) {
    $options = $tabs[$tab_name]['options'];

    if ($options['view']) {
      $options['view_arguments'] = is_array($options['view_arguments']) ? $options['view_arguments'] : array();

      $options['view']->set_display($options['view_display_id']);
      $options['view']->set_arguments($options['view_arguments']);
      $filters = $options['view']->display_handler->get_option('filters');
      $options['view']->display_handler->set_option('filters', $filters);
      $options['view']->init_handlers();
      $options['view']->pre_execute();
      $options['view']->execute();
      if ($options['view']->exposed_widgets) {
        $output .= '<div id="nrembrowser-exposed-widgets">'. $options['view']->exposed_widgets .'</div>';
      }
    }

    $output .= drupal_get_form($tabs[$tab_name]['form'], $field, $nid, $options);
  }

  $output = '<div id="nrembrowser-tab-wrapper"><div id="nrembrowser-add">'. theme('status_messages') . $output .'</div></div>';

  if ($js) {
    // Our form submit requests an array for an AJAX load.
    drupal_json(array('status' => TRUE, 'data' => $output));
  }
  else {
    // This is for the simpler $.load.
    print $output;
  }
}

/**
 * Page callback for nrembrowser/media/add.
 *
 * This will display the dialog browser with tabs at top.
 */
function nrembrowser_add_media_page($field_name = NULL) {
  $field_name = $_POST['field_name'];
  $nid = $_POST['current'];
  $field = content_fields($field_name);

  $all_tabs = module_invoke_all('nrembrowser_media', $field);
  // Invoke hook_nrembrowser_media_alter().
  drupal_alter('nrembrowser_media', $all_tabs, $field);

  $tabs = array();
  foreach ($all_tabs as $tab_name => $tab) {
    $tabs[] = l(t('@name', array('@name' => $tab['title'])), 'nrembrowser/media/tab/'. $tab_name, array('query' => 'field_name='. $field_name .'&current='. $nid));
  }

  $output = theme('status_messages') . theme('item_list', $tabs, NULL, 'ul', array('id' => 'nrembrowser-tabs-list'));
  $output = '<div id="nrembrowser-add-wrapper"><div id="nrembrowser-add"><div id="nrembrowser-tabs">'. $output .'</div></div></div>';

  if ($_POST['js']) {
    drupal_json(array('status' => TRUE, 'data' => $output));
  }
  else {
    return $output;
  }
}

/**
 * Implementation of hook_nrembrowser_media().
 */
function nrembrowser_nrembrowser_media($field = NULL) {
  // We define an array of tabs to display for the browser.
  $tabs = array();

  // First, add a tab for all available media.
  $tabs['nrembrowser_media_library'] = array(
    'title' => 'All',
    'form' => 'nrembrowser_add_media_page_form',
    'options' => array(),
    'weight' => -5,
  );

  // @TODO: Admin settings for view tabs per field + wysiwyg.
  // @TODO: Use field settings for each field.
  if (module_exists('views')) {
    foreach (nrembrowser_variable_get('wysiwyg_tabs_views') as $index => $tab) {
      // Add a tab for each required view.
      $view = views_get_view($tab['view_name']);
      if (!$view || !$view->access($tab['view_display_id'])) {
        // Don't display the tab if we don't have access.
        continue;
      }
      $tab['view'] = $view;
      $tabs['nrembrowser_media_view_'. $index] = array(
        'title' => t($view->display[$tab['view_display_id']]->display_options['title']),
        'form' => 'nrembrowser_add_media_page_form',
        'options' => $tab,
        'weight' => -3,
      );
    }
  }

  // Next we'll add tabs to filter by allowed types.
  // @TODO: Allow us to turn on/off & weigh tabs.
  // @TODO: Reorder tabs by weight.
  // @TODO: Use table dragdrop for admin of tabs.
  // @TODO: Allow us to set the default tab.
  // @TODO: Set default view of 'My media' as the selected view, after 'All'.
  foreach (node_get_types('names') as $type => $name) {
    if (!isset($field)) {
      // This browser is for WYSIWYG, so we'll use the global types.
      $allowed = nrembrowser_variable_get('wysiwyg_type_allowed_'. $type);
    }
    else {
      // Use the field types instead. Note that it won't allow us to filter
      // by type if we are using a View for the nodereference allowed types.
      $allowed = $field['referenceable_types'][$type];
    }

    if ($allowed) {
      // Add a tab filtering by this specific type.
      $tabs['nrembrowser_media_library_'. $type] = array(
        'title' => $name,
        'form' => 'nrembrowser_add_media_page_form',
        'options' => array(
          'types' => array(
            $type
          ),
        ),
        'weight' => 0,
      );
    }
  }

  return $tabs;
}

function nrembrowser_nrembrowser_media_alter(&$tabs, $field) {
//   dpm($tabs);
//   dpm($field);
  if (!isset($field)) {
    // Load up WYSIWYG ordering.
//     $tabs =
  }
}

/**
 * Determine the nid of the current selection of the add media page.
 *
 * @param array $field
 *  The specified content field.
 * @return integer
 *  The node NID of the selected media, if valid.
 */
function nrembrowser_add_media_page_current_nid($field = NULL, $title = NULL, $reset = FALSE) {
  static $nid;

  if (!isset($nid) || $reset) {
    if ($title) {
      preg_match('/^(?:\s*|(.*) )?\[\s*nid\s*:\s*(\d+)\s*\]$/', $title, $matches);
      if (!empty($matches)) {
        // Explicit [nid:n].
        list(, $title, $nid) = $matches;
        if (!empty($title) && ($n = node_load($nid)) && trim($title) != trim($n->title)) {
          drupal_set_message(t('Title mismatch. Please check your selection.'), 'error');
          $nid = NULL;
        }
      }
      else {
        // No explicit nid.
        $reference = _nodereference_potential_references($field, $value, 'equals', NULL, 1);
        if (empty($reference)) {
          drupal_set_message(t('Found no valid post with that title.'), 'error');
        }
        else {
          // TODO:
          // the best thing would be to present the user with an additional form,
          // allowing the user to choose between valid candidates with the same title
          // ATM, we pick the first matching candidate...
          $nid = key($reference);
        }
      }
    }
  }
  return $nid;
}

/**
 * Implementation of hook_filter().
 */
function nrembrowser_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(0 => t('Node embedded media'));

    case 'description':
      return t('Allows users to embed media and other content from nodes, using a modal pop-up browser if you also have !WYSIWYG installed and configured (using the provided %plugin plugin). Without the browser, embed content using %notation notation.', array('!WYSIWYG' => l(t('WYSIWYG'), 'http://drupal.org/project/wysiwyg', array('attributes' => array('target' => '_blank'))), '%plugin' => 'Node embed media browser', '%notation' => '[[nid:123]]'));

    case "process":
      // @TODO: Can we pass $format to the callback?
      return preg_replace_callback('@\[\[nid:(\d+);?(.*?)\]\]@i', 'nrembrowser_embedded_node', $text);
    default:
      return $text;
  }
}

/**
 * Helper function for nrembrowser_filter().
 */
function nrembrowser_embedded_node($matches) {
  // @TODO: Validate the node type by filter...
  $nid = $matches[1];
  $styles = explode(';', $matches[2]);
  $attributes = array();
  $passed_attributes = '';
  foreach ($styles as $style) {
    list($attribute, $key) = explode(':', $style);
    $attribute = check_plain(trim($attribute));
    $key = check_plain(trim($key));
    if ($attribute) {
      $attributes[$attribute] = $key;
      if (!in_array($attribute, array('imagecache', 'styleName'))) {
        $passed_attributes .= $attribute .':'. $key .';';
      }
    }
  }

  // Extract any set imagecache & styles presets.
  $imagecache_preset = $attributes['imagecache'] ? $attributes['imagecache'] : '';
  $style_name = $attributes['styleName'];

  unset($attributes['imagecache']);
  unset($attributes['styleName']);

  if (module_exists('styles')) {
    $node = node_load($nid);

    if ($node && node_access('view', $node)) {
      $instance = styles_instance('nodereference', $style_name, $node);

      // Apply any other attributes.
      foreach ($attributes as $key => $value) {
        if ($key == 'float') {
          $instance->unshift_effect(array('name' => 'float', 'settings' => array('float' => $value)));
        }
        else if (in_array($key, array('width', 'height'))) {
          $instance->unshift_effect(array('name' => 'resize', 'settings' => array($key => $value)));
        }
        else if (is_callable(array($instance, ($function = ('set_'. $key))))) {
          $instance->$function($value);
        }
        else {
          $instance->set($key, $value);
        }
      }
      return theme('styles', 'nodereference', $style_name, $node, $instance);
    }
  }
  $node = node_load($nid);
  return theme('nrembrowser_thumbnail', $nid, $node->title, $node->title, FALSE, NULL, $imagecache_preset, array('style' => $passed_attributes));
}

/**
 * Implementation of hook_filter_tips().
 */
function nrembrowser_filter_tips($delta, $format, $long = false) {
  if ($long) {
    if (module_exists('wysiwyg')) {
      $output = t('Using the provided rich text editor, you can select content by pressing the %embed button and making a selection: !image', array('%embed' => t('Embed content'), '!image' => theme('image', drupal_get_path('module', 'nrembrowser') .'/plugins/nrembrowser/images/nrembrowser.gif')));
      $output .= t('<br />If you do not have access to that editor or have it disabled, you may use %nid notation instead to manually insert the media or content from another node.', array('%nid' => '[[nid:123]]'));
    }
    else {
      $output = t('You may use %nid notation to manually insert the media or content from another node.', array('%nid' => '[[nid:123]]'));
    }
  }
  else {
    $output = t('You may use %nid notation to manually insert the media or content from another node.', array('%nid' => '[[nid:123]]'));
  }
  return $output;
}

/**
 * Register a directory containing Wysiwyg plugins.
 *
 * @param $type
 *   The type of objects being collected: either 'plugins' or 'editors'.
 * @return
 *   A sub-directory of the implementing module that contains the corresponding
 *   plugin files. This directory must only contain integration files for
 *   Wysiwyg module.
 */
function nrembrowser_wysiwyg_include_directory($type) {
  switch ($type) {
    case 'plugins':
      // You can just return $type, if you place your Wysiwyg plugins into a
      // sub-directory named 'plugins'.
      return $type;
  }
}

/**
 * Implementation of Styles module hook_styles_register().
 */
function nrembrowser_styles_register() {
  return array(
    'NrembrowserStyles' => array(
      'field_types' => 'nodereference',
      'name' => t('nrembrowser'),
      'description' => t('nrembrowser styles.'),
      'path' => drupal_get_path('module', 'nrembrowser') .'/includes/styles',
      'file' => 'NrembrowserStyles.inc',
    ),
  );
}

/**
 * Styles filter callback.
 *
 * This will determine the correct style container corresponding to node type.
 */
function nrembrowser_styles_filter($object, $element) {
  // @TODO: nodeapi_load to mark nodes as loaded.
  // @TODO: only load if it's already been;
  // @TODO: otherwise simply query for the title.
  $node = node_load($object->nid);
  return $node->type;
}

/**
 * Page callback for nrembrowser/browser/thumbnail/%node.
 */
function nrembrowser_media_display_thumbnail($node, $imagecache_preset = '') {
  if (module_exists('styles')) {
    $style_name = $_GET['styleName'];
    $instance = styles_instance('nodereference', $style_name, $node);
    $instance->push_effect(array('name' => 'thumbnail', 'settings' => array()));
    $output = theme('styles', 'nodereference', $style_name, $node, $instance);
    if (preg_match('@src\=\"(.*?)\"@i', $output, $matches)) {
      return drupal_goto($matches[1]);
    }
  }

  // Discover the preview image associated with this node.
  $image = nrembrowser_node_image($node->nid);

  // If there is no image, return a 404.
  if (!$image) {
    drupal_not_found();
  }

  // Redirect to the associated image.
  if (module_exists('imagecache') && (stripos($image, '://') === FALSE) && $imagecache_preset) {
    drupal_goto(imagecache_create_url($imagecache_preset, $image, FALSE, FALSE));
  }
  else {
    drupal_goto($image);
  }
}

/**
 * Implementation of hook_views_api().
 */
function nrembrowser_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'nrembrowser') . '/includes/views',
  );
}

/**
 * Implementation of hook_init().
 */
function nrembrowser_init() {
  // Add css for styled floats.
  drupal_add_css(drupal_get_path('module', 'nrembrowser') .'/themes/css/nrembrowser.styles.css');
  // Add css for "Add media" dialog popup's iframe.
  drupal_add_css(drupal_get_path('module', 'nrembrowser') .'/themes/css/nrembrowser.widget.css');
}
